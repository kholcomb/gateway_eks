# OpenWebUI Helm Chart Values
# Helm repo: https://helm.openwebui.com/

# Pin to official image for stability
image:
  repository: ghcr.io/open-webui/open-webui
  tag: "v0.6.41"
  pullPolicy: IfNotPresent

# Connect to LiteLLM as OpenAI-compatible backend
openaiBaseApiUrls:
  - "http://litellm.litellm.svc.cluster.local:4000/v1"

# API key from ExternalSecret
extraEnvVars:
  - name: OPENAI_API_KEY
    valueFrom:
      secretKeyRef:
        name: openwebui-secrets
        key: openai-api-key

  # Webui secret key for session encryption (required for multi-node deployments)
  - name: WEBUI_SECRET_KEY
    valueFrom:
      secretKeyRef:
        name: openwebui-secrets
        key: webui-secret-key

  # ============================================
  # Okta OIDC Authentication Configuration
  # ============================================
  # Prerequisites:
  #   1. Create Okta OIDC application with:
  #      - Sign-in redirect URI: https://<openwebui-domain>/oauth/oidc/callback
  #      - Sign-out redirect URI: https://<openwebui-domain>
  #   2. Store client credentials in AWS Secrets Manager
  #   3. Create ExternalSecret for okta-oidc-secrets

  # WEBUI_URL must be set BEFORE enabling OAuth (cannot be changed after)
  - name: WEBUI_URL
    value: "https://openwebui.example.com"  # TODO: Update to actual domain

  # Enable OAuth signup (disables local registration)
  - name: ENABLE_OAUTH_SIGNUP
    value: "true"

  # OAuth provider display name
  - name: OAUTH_PROVIDER_NAME
    value: "Okta"

  # Okta OIDC discovery endpoint
  # Format: https://<your-okta-domain>/oauth2/default/.well-known/openid-configuration
  - name: OPENID_PROVIDER_URL
    valueFrom:
      secretKeyRef:
        name: okta-oidc-secrets
        key: openid-provider-url

  # Okta client credentials
  - name: OAUTH_CLIENT_ID
    valueFrom:
      secretKeyRef:
        name: okta-oidc-secrets
        key: client-id
  - name: OAUTH_CLIENT_SECRET
    valueFrom:
      secretKeyRef:
        name: okta-oidc-secrets
        key: client-secret

  # OAuth scopes (include groups for RBAC)
  - name: OAUTH_SCOPES
    value: "openid email profile groups"

  # Merge accounts if email matches existing user
  - name: OAUTH_MERGE_ACCOUNTS_BY_EMAIL
    value: "true"

  # ============================================
  # Group & Role Management (Optional)
  # ============================================
  # Sync Okta groups to OpenWebUI groups on login
  - name: ENABLE_OAUTH_GROUP_MANAGEMENT
    value: "true"

  # Auto-create groups from Okta claims
  - name: ENABLE_OAUTH_GROUP_CREATION
    value: "true"

  # Claim containing group memberships
  - name: OAUTH_GROUP_CLAIM
    value: "groups"

  # Role-based access (optional - uncomment to enable)
  # - name: ENABLE_OAUTH_ROLE_MANAGEMENT
  #   value: "true"
  # - name: OAUTH_ROLES_CLAIM
  #   value: "roles"
  # - name: OAUTH_ADMIN_ROLES
  #   value: "openwebui-admin"

  # Disable local password auth (OAuth only)
  - name: ENABLE_PASSWORD_AUTH
    value: "false"

  # Disable local signup form
  - name: ENABLE_SIGNUP
    value: "false"

# Disable bundled Ollama (using LiteLLM instead)
ollama:
  enabled: false

# Disable bundled Pipelines
pipelines:
  enabled: false

# Persistence on EBS with gp3 storage class
persistence:
  enabled: true
  size: 10Gi
  storageClass: gp3
  accessModes:
    - ReadWriteOnce

# Internal service only (no public ingress)
service:
  type: ClusterIP
  port: 80

# No ingress - access via port-forward from bastion
ingress:
  enabled: false

# Resource limits
resources:
  requests:
    cpu: "250m"
    memory: "512Mi"
  limits:
    cpu: "1000m"
    memory: "2Gi"

# Liveness and readiness probes
livenessProbe:
  httpGet:
    path: /health
    port: http
  initialDelaySeconds: 30
  periodSeconds: 10

readinessProbe:
  httpGet:
    path: /health/db
    port: http
  initialDelaySeconds: 10
  periodSeconds: 5

# Node selector (optional - for cost optimization)
# nodeSelector:
#   node.kubernetes.io/instance-type: t3.medium

# Pod annotations for monitoring
podAnnotations:
  prometheus.io/scrape: "true"
  prometheus.io/port: "8080"

# Pod security context
podSecurityContext:
  fsGroup: 1000

# Container security context
containerSecurityContext:
  runAsNonRoot: true
  runAsUser: 1000
