# kube-prometheus-stack Helm Chart Values
# Helm repo: https://prometheus-community.github.io/helm-charts

# Prometheus configuration
prometheus:
  prometheusSpec:
    # Enable ServiceMonitor discovery from all namespaces
    serviceMonitorSelectorNilUsesHelmValues: false
    podMonitorSelectorNilUsesHelmValues: false

    # Retention settings (PoC: reduced retention)
    retention: 7d
    retentionSize: "5GB"

    # Storage - use EBS gp3 (PoC: reduced size)
    storageSpec:
      volumeClaimTemplate:
        spec:
          storageClassName: gp3
          accessModes: ["ReadWriteOnce"]
          resources:
            requests:
              storage: 20Gi

    # Resource limits (PoC: reduced resources)
    resources:
      requests:
        cpu: "200m"
        memory: "512Mi"
      limits:
        cpu: "1000m"
        memory: "2Gi"

    # Scrape interval
    scrapeInterval: 30s
    evaluationInterval: 30s

# Grafana configuration
grafana:
  enabled: true

  # Admin credentials - change in production!
  adminUser: admin
  # adminPassword will be auto-generated if not set
  # Or use existing secret:
  # admin:
  #   existingSecret: grafana-admin-secret
  #   userKey: admin-user
  #   passwordKey: admin-password

  # Persistence (PoC: reduced size)
  persistence:
    enabled: true
    size: 5Gi
    storageClassName: gp3

  # Default datasources (auto-configured)
  sidecar:
    dashboards:
      enabled: true
      label: grafana_dashboard
      searchNamespace: ALL
      # Folder for custom dashboards
      folderAnnotation: grafana_folder
      provider:
        foldersFromFilesStructure: true
    datasources:
      enabled: true

  # Additional datasources for Jaeger tracing
  additionalDataSources:
    - name: Jaeger
      type: jaeger
      url: http://jaeger-all-in-one.monitoring.svc.cluster.local:16686
      access: proxy
      isDefault: false

  # Default Kubernetes dashboards
  defaultDashboardsEnabled: true
  defaultDashboardsTimezone: browser

  # Resource limits
  resources:
    requests:
      cpu: "100m"
      memory: "256Mi"
    limits:
      cpu: "500m"
      memory: "512Mi"

  # Service configuration
  service:
    type: ClusterIP

  # Ingress disabled - access via port-forward
  ingress:
    enabled: false

# Alertmanager configuration
alertmanager:
  enabled: true

  alertmanagerSpec:
    # Storage (PoC: reduced size)
    storage:
      volumeClaimTemplate:
        spec:
          storageClassName: gp3
          accessModes: ["ReadWriteOnce"]
          resources:
            requests:
              storage: 2Gi

    # Resource limits
    resources:
      requests:
        cpu: "50m"
        memory: "128Mi"
      limits:
        cpu: "200m"
        memory: "256Mi"

  # Alertmanager config - customize for your notification channels
  config:
    global:
      resolve_timeout: 5m

    route:
      group_by: ['alertname', 'namespace']
      group_wait: 30s
      group_interval: 5m
      repeat_interval: 4h
      receiver: 'null'
      routes:
        # Add custom routes here for specific alerts
        - match:
            severity: critical
          receiver: 'null'  # TODO: Configure Slack/PagerDuty/etc.

    receivers:
      - name: 'null'
      # TODO: Add your notification receivers
      # - name: 'slack'
      #   slack_configs:
      #     - api_url: 'https://hooks.slack.com/services/...'
      #       channel: '#alerts'

# Node Exporter - enabled by default
nodeExporter:
  enabled: true

# Kube State Metrics - enabled by default
kubeStateMetrics:
  enabled: true

# Prometheus Operator
prometheusOperator:
  enabled: true
  resources:
    requests:
      cpu: "100m"
      memory: "128Mi"
    limits:
      cpu: "500m"
      memory: "256Mi"

# Disable components not needed for this setup
kubeApiServer:
  enabled: true
kubeControllerManager:
  enabled: false  # Not accessible on EKS
kubeScheduler:
  enabled: false  # Not accessible on EKS
kubeProxy:
  enabled: true
kubeEtcd:
  enabled: false  # Not accessible on EKS

# Default rules
defaultRules:
  create: true
  rules:
    alertmanager: true
    general: true
    k8s: true
    kubeApiserverAvailability: true
    kubeApiserverBurnrate: true
    kubeApiserverHistogram: true
    kubeApiserverSlos: true
    kubePrometheusGeneral: true
    kubePrometheusNodeRecording: true
    kubernetesApps: true
    kubernetesResources: true
    kubernetesStorage: true
    kubernetesSystem: true
    node: true
    nodeExporterAlerting: true
    nodeExporterRecording: true
    prometheus: true
    prometheusOperator: true
